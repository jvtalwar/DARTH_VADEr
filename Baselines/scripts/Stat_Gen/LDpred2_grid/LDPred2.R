# Load packages bigsnpr and bigstatsr
library(bigsnpr)
library(pROC)
library(argparse)
options(bigstatsr.check.parallel.blas = FALSE)
options(default.nproc.blas = NULL)

# Create parser
parser <- ArgumentParser(description = "LDPred2.R script parser")

# Add arguments
parser$add_argument("--sumstats", required = TRUE, help = "Path to summary statistics")
parser$add_argument("--corr_write_path", help = "Path to write correlation matrix generated by LDPred2.", default = "~/projects/BetterRiskScores/InSNPtion/Galbatorix/DucksInARow/Notebooks/PredictionGeneration/tmp-data/corr")
parser$add_argument("--ld_ref", required = TRUE, help = "Path to LD reference (folder) chromosome-level .bed files.")
parser$add_argument("--train", required = TRUE, help = "Path to train set chromosome-level .bed files.")
parser$add_argument("--val", required = TRUE, help = "Path to validation set chromosome-level .bed files.")
parser$add_argument("--test", required = TRUE, help = "Path to test set chromosome-level .bed files.")
parser$add_argument("--write_path", required = TRUE, help = "Path to write best train, val, and test set LD predictions.")
parser$add_argument("--num_chroms", help = "The total number of chromosomes", default = 22)
parser$add_argument("--pheno_train_val", help = "Path phenotype file tor training and validation set.", default = "~/projects/BetterRiskScores/InSNPtion/Galbatorix/DucksInARow/PhenosAndIDs/PC/ellipse.pheno.tsv")
parser$add_argument("--pheno_test", help = "Path phenotype file tor test set.", default = "~/projects/BetterRiskScores/InSNPtion/Galbatorix/DucksInARow/PhenosAndIDs/PC/ukb.ellipse.pheno.tsv")
parser$add_argument("--classic_p_subset", action = "store_true", help = "Flag to run LDPred2 over narrower pval space of {5e-8, 5e-7, 5e-6, 5e-5, 5e-4}")


# Parse arguments
args <- parser$parse_args()

#Load in summary statistics:
sumstats <- bigreadr::fread2(args$sumstats)
#Wang sum stats follow different order of columns and need to be reordered to align with expectation below or will throw error
sumstats <- setNames(sumstats, c("index", "chr", "pos", "rsid", "a0", "a1", "p", "beta", "beta_se", "N"))

fullPath <- file.path(args$ld_ref, "chr")

corrMatrixPath <- args$corr_write_path
genomesPosition <- "~/projects/BetterRiskScores/InSNPtion/Galbatorix/DucksInARow/Notebooks/PredictionGeneration/tmp-genomes-position"

# Get maximum amount of cores
NCORES <- nb_cores()

# Initialize variables for storing the LD score and LD matrix
corr <- NULL
ld <- NULL
# We want to know the ordering of samples in the bed file 
info_snp <- NULL
fam.order <- NULL

for (chr in 1:args$num_chroms){
    # preprocess the bed file (only need to do once for each data set)
    if (!file.exists(paste0(fullPath, chr, ".rds"))){
        snp_readBed(paste0(fullPath, chr, ".bed")) 
    }
    # now attach the genotype object
    obj.bigSNP <- snp_attach(paste0(fullPath, chr, ".rds"))
    
    # extract the SNP information from the genotype
    map <- obj.bigSNP$map[-3]
    names(map) <- c("chr", "rsid", "pos", "a0", "a1") #opposite classic implementation - as grievous process sets ALT allele to reference 
    map$chr <- as.character(map$chr)

    # perform SNP matching
    tmp_snp <- snp_match(sumstats[sumstats$chr==chr,], map)
    info_snp <- rbind(info_snp, tmp_snp)

    # Assign the genotype to a variable for easier downstream analysis
    genotype <- obj.bigSNP$genotypes
    
    # Rename the data structures
    CHR <- as.integer(map$chr)
    POS <- map$pos
    
    # get the CM information from 1000 Genome
    # will download the 1000G file to the current directory (".")
    POS2 <- snp_asGeneticPos(CHR, POS, dir = genomesPosition)

     # calculate LD; Extract SNPs that are included in the chromosome
    ind.chr <- which(tmp_snp$chr == chr)
    ind.chr2 <- tmp_snp$`_NUM_ID_`[ind.chr]
    
    # Calculate the LD
    corr0 <- snp_cor(genotype, ind.col = ind.chr2, ncores = NCORES, infos.pos = POS2[ind.chr2], size = 3 / 1000)
    
    if (chr == 1) {
        ld <- Matrix::colSums(corr0^2)
        corr <- as_SFBM(corr0, corrMatrixPath)
    } else {
        ld <- c(ld, Matrix::colSums(corr0^2))
        corr$add_columns(corr0, nrow(corr))
    }

} 

print(paste0("Dimension of correlation matrix: ", dim(corr)))

NoNAinLD = sum(is.na(ld)) == 0
print(paste0("No NA values in ld calculation? ", NoNAinLD))

if (!NoNAinLD){
    stop("LD calculation values have NA values. Exiting...")
}

#Calculate heritability estimate:
df_beta <- info_snp[,c("beta", "beta_se", "N", "_NUM_ID_")]
ldsc <- snp_ldsc(ld, length(ld), chi2 = (df_beta$beta / df_beta$beta_se)^2, sample_size = df_beta$N, blocks = NULL)
h2_est <- ldsc[["h2"]]
print(paste0("Heritabiltiy estimate: ", h2_est))

#Load train, val, and test genotypes and ensure no misalignment with info_snp:
genotypeDirs = c(args$train, args$val, args$test)

for (datasetPath in genotypeDirs){
    currentDataset <- tail(strsplit(datasetPath, split = "/")[[1]], 1)
    print(paste0("Beginning ", currentDataset))
    datasetSpecific <- NULL
    for (chr in 1:args$num_chroms) { #<-- again only 21 as no 22 QC passed SNPs
        # preprocess the bed file (only need to do once for each data set)
        if (!file.exists(paste0(datasetPath, "/chr", chr, ".rds"))){
            snp_readBed(paste0(datasetPath, "/chr", chr, ".bed")) 
        }
    
        # now attach the genotype object
        rSnpObject <- snp_attach(paste0(datasetPath, "/chr", chr, ".rds"))
        
        # extract the SNP information from the genotype
        map <- rSnpObject$map[-3]
        names(map) <- c("chr", "rsid", "pos", "a0", "a1") #opposite classic implementation - as grievous process sets ALT allele to reference 
        map$chr <- as.character(map$chr)
        
        # perform SNP matching
        tmp_snp <- snp_match(sumstats[sumstats$chr==chr,], map)
        datasetSpecific <- rbind(datasetSpecific, tmp_snp)
    }
    datasetStatus <- all(datasetSpecific == info_snp)
    print(paste0("Completed ", tail(strsplit(datasetPath, split = "/")[[1]], 1), "; STATUS: ", datasetStatus))
    if (!datasetStatus){
        stop(paste0("Dataset ", currentDataset, " SNP set/orientation does not align with info_snp. Exiting..."))
    }
}

#Define grid for LDPred2:
names(df_beta) <- c("beta", "beta_se", "n_eff", "_NUM_ID_")

p_seq <- NULL
if (args$classic_p_subset){
    p_seq <- c(5e-8,5e-7,5e-6,5e-5,5e-4)
}else {
    p_seq <- signif(seq_log(1e-4, 1, length.out = 17), 2)
}
h2_seq <- round(h2_est * c(0.3, 0.7, 1, 1.4, 1.9), 4)
grid.param <-
    expand.grid(p = p_seq,
            h2 = h2_seq,
            sparse = c(FALSE, TRUE))

# Get adjusted beta from grid model
beta_grid <-
    snp_ldpred2_grid(corr, df_beta, grid.param, ncores = NCORES)

cat("\nSNP effect size correction completed!\n")

# Function to check if all elements in a column are NA
all_na <- function(x) {
  all(is.na(x))
}

# Apply the function to each column of the matrix
na_columns <- apply(beta_grid, 2, all_na)

# Get the indices of columns that are not completely NA
na_column_indices <- which(!na_columns)

# Print the indices of columns not completely filled with NAs
print(paste0("Number of non NA columns: ", length(na_column_indices)))
print(paste0("Non NA columns:  ", na_column_indices))
validLdParams <- grid.param[na_column_indices, ]
cat(paste0("These correspond to the following values:\n ", validLdParams, "\n"))

beta_grid_clean <- beta_grid[, na_column_indices]

#Generate LDPred2 scores for all datasets:
pheno <- read.table(args$pheno_train_val)
names(pheno) <- c("IID", "AGE", "SEX", "PHENOTYPE", "FAMILY_HISTORY","ANCESTRY")
pheno$PHENOTYPE <- pheno$PHENOTYPE - 1

trainDir <- genotypeDirs[1]
trainPredGrid <- NULL

print("Beginning TRAIN Predictions: ")
for(chr in 1:args$num_chroms){
    rSnpObject <- snp_attach(paste0(trainDir, "/chr", chr, ".rds"))
    genotype <- rSnpObject$genotypes
    #Calc PRS for all samples
    ind.test <- 1:nrow(genotype) #seems unused - from tutorial so leaving in...
    
    # Extract SNPs in this chromosome
    chr.idx <- which(info_snp$chr == chr)
    ind.chr <- info_snp$`_NUM_ID_`[chr.idx]
    
    tmp <- big_prodMat(genotype, 
                       beta_grid_clean[chr.idx, ]) # chr.idx - is the row elements of info_snp which are in order - Num_ID reset's the values which restart at each chromosome...

    if(is.null(trainPredGrid)){
        trainPredGrid <- tmp
    }else{
        trainPredGrid <- trainPredGrid + tmp
    }
    
}

cat(paste0("TRAIN Predictions complete with output dimension: " , dim(trainPredGrid) , "\n"))

rSnpObject <- snp_attach(paste0(trainDir, "/chr1.rds"))
trainIDs <- rSnpObject$fam$sample.ID
trainPheno <- pheno[pheno$IID %in% trainIDs,]
trainFamOrder <- match(trainIDs, trainPheno$IID)
trainPhenoOrdered <- trainPheno[trainFamOrder, ]

#TRAIN SET AUCs
trainAUCs <- list()
trainCIs <- list()
cat("TRAIN AUCs: \n")
for (i in 1:ncol(trainPredGrid)) {
  # Extract the predictions for the current column
  predicted <- trainPredGrid[, i]
  
  # Calculate ROC curve
  roc_obj <- roc(trainPhenoOrdered$PHENOTYPE, predicted)
  
  # Calculate AUC
  auc_value <- auc(roc_obj)
  
  # Calculate confidence interval for AUC
  ci_auc <- ci.auc(roc_obj)
  
  # Store the results in lists
  trainAUCs[[i]] <- auc_value
  trainCIs[[i]] <- ci_auc
}

# Display the results
for (i in 1:ncol(trainPredGrid)) {
  cat("LD Params: ", paste(validLdParams[i, ], collapse = " "), "\n")
  #cat("Column", i, ":\n")
  cat("AUC:", trainAUCs[[i]], "\n")
  cat("95% CI:", trainCIs[[i]], "\n\n")
}

# Get the indices that would sort trainAUCs in descending order
sorted_indices <- order(unlist(trainAUCs), decreasing = TRUE)

# Print the sorted indices
print(paste0("TRAIN predictions sorted indices by AUC performance: " , sorted_indices))

# Use the sorted indices to get the sorted trainAUCs
sorted_trainAUCs <- trainAUCs[sorted_indices[1]] #<-- get max value:

# Print the sorted AUC values
print(paste0("TRAIN best AUC: ", sorted_trainAUCs))

trainSetScores <- trainPhenoOrdered[,c("IID", "PHENOTYPE")]
trainSetScores <- as.data.frame(cbind(trainSetScores, trainPredGrid))

write.table(trainSetScores, file = file.path(args$write_path, "Train_ALL_Preds.tsv"), sep = "\t", row.names = FALSE, quote = FALSE)

#Validation set:
valDir <- genotypeDirs[2]
valPredGrid <- NULL

for(chr in 1:args$num_chroms){
    rSnpObject <- snp_attach(paste0(valDir, "/chr", chr, ".rds"))
    genotype <- rSnpObject$genotypes
    #Calc PRS for all samples
    ind.test <- 1:nrow(genotype) #seems unused - from tutorial so leaving in...
    
    # Extract SNPs in this chromosome
    chr.idx <- which(info_snp$chr == chr)
    ind.chr <- info_snp$`_NUM_ID_`[chr.idx]
    
    tmp <- big_prodMat(genotype, 
                       beta_grid_clean[chr.idx, ]) # chr.idx - is the row elements of info_snp which are in order - Num_ID reset's the values which restart at each chromosome...

    if(is.null(valPredGrid)){
        valPredGrid <- tmp
    }else{
        valPredGrid <- valPredGrid + tmp
    }
    
}

cat(paste0("VAL Predictions complete with output dimension: " , dim(valPredGrid) , "\n"))

rSnpObject <- snp_attach(paste0(valDir, "/chr1.rds"))
valIDs <- rSnpObject$fam$sample.ID
valPheno <- pheno[pheno$IID %in% valIDs,]
valFamOrder <- match(valIDs, valPheno$IID)
valPhenoOrdered <- valPheno[valFamOrder, ]

valAUCs <- list()
valCIs <- list()

cat("VAL AUCs: \n")
for (i in 1:ncol(valPredGrid)) {
  # Extract the predictions for the current column
  predicted <- valPredGrid[, i]
  
  # Calculate ROC curve
  roc_obj <- roc(valPhenoOrdered$PHENOTYPE, predicted)
  
  # Calculate AUC
  auc_value <- auc(roc_obj)
  
  # Calculate confidence interval for AUC
  ci_auc <- ci.auc(roc_obj)
  
  # Store the results in lists
  valAUCs[[i]] <- auc_value
  valCIs[[i]] <- ci_auc
}

# Display the results
for (i in 1:ncol(valPredGrid)) {
  cat("LD Params: ", paste(validLdParams[i, ], collapse = " "), "\n")
  #cat("Column", i, ":\n")
  cat("AUC:", valAUCs[[i]], "\n")
  cat("95% CI:", valCIs[[i]], "\n\n")
}


# Get the indices that would sort val AUCs in descending order
val_sorted_indices <- order(unlist(valAUCs), decreasing = TRUE)

# Print the sorted indices
print(paste0("VAL predictions sorted indices by AUC performance: " , val_sorted_indices))

# Use the sorted indices to get the sorted val AUCs
sorted_valAUCs <- valAUCs[val_sorted_indices[1]] #<-- get max value:

# Print the sorted AUC values
print(paste0("VAL best AUC: ", sorted_valAUCs))

valSetScores <- valPhenoOrdered[,c("IID", "PHENOTYPE")]
valSetScores <- as.data.frame(cbind(valSetScores, valPredGrid))

write.table(valSetScores, file = file.path(args$write_path, "Val_ALL_Preds.tsv"), sep = "\t", row.names = FALSE, quote = FALSE)

#Test Set UKBB:
testDir <- genotypeDirs[3]
testPredGrid <- NULL

for(chr in 1:args$num_chroms){
    rSnpObject <- snp_attach(paste0(testDir, "/chr", chr, ".rds"))
    #genotype <- rSnpObject$genotypes
    genotypeWithNAs <- rSnpObject$genotypes
    genotype <- snp_fastImputeSimple(genotypeWithNAs, method = "mean2", ncores = 8) #

    #Calc PRS for all samples
    ind.test <- 1:nrow(genotype) #seems unused - from tutorial so leaving in...
    
    # Extract SNPs in this chromosome
    chr.idx <- which(info_snp$chr == chr)
    ind.chr <- info_snp$`_NUM_ID_`[chr.idx]
    
    tmp <- big_prodMat(genotype, 
                       beta_grid_clean[chr.idx, ]) # chr.idx - is the row elements of info_snp which are in order - Num_ID reset's the values which restart at each chromosome...

    if(is.null(testPredGrid)){
        testPredGrid <- tmp
    }else{
        testPredGrid <- testPredGrid + tmp
    }
    
}

cat(paste0("TEST Predictions complete with output dimension: " , dim(testPredGrid) , "\n"))

ukbbPhenoPath <- args$pheno_test
ukbbPheno <- read.table(ukbbPhenoPath)
names(ukbbPheno) <- c("IID", "AGE", "SEX", "PHENOTYPE","ANCESTRY")
ukbbPheno$PHENOTYPE <- ukbbPheno$PHENOTYPE - 1

rSnpObject <- snp_attach(paste0(testDir, "/chr1.rds"))
testIDs <- rSnpObject$fam$sample.ID
testPheno <- ukbbPheno[ukbbPheno$IID %in% testIDs,]
testFamOrder <- match(testIDs, testPheno$IID)
testPhenoOrdered <- testPheno[testFamOrder, ]

testAUCs <- list()
testCIs <- list()

cat("TEST AUCs: \n")

for (i in 1:ncol(testPredGrid)) {
  # Extract the predictions for the current column
  predicted <- testPredGrid[, i]
  
  # Calculate ROC curve
  roc_obj <- roc(testPhenoOrdered$PHENOTYPE, predicted)
  
  # Calculate AUC
  auc_value <- auc(roc_obj)
  
  # Calculate confidence interval for AUC
  ci_auc <- ci.auc(roc_obj)
  
  # Store the results in lists
  testAUCs[[i]] <- auc_value
  testCIs[[i]] <- ci_auc
}

# Display the results
for (i in 1:ncol(testPredGrid)) {
  cat("LD Params: ", paste(validLdParams[i, ], collapse = " "), "\n")
  #cat("Column", i, ":\n")
  cat("AUC:", testAUCs[[i]], "\n")
  cat("95% CI:", testCIs[[i]], "\n\n")
}

# Get the indices that would sort trainAUCs in descending order
test_sorted_indices <- order(unlist(testAUCs), decreasing = TRUE)

# Print the sorted indices
print(paste0("TEST predictions sorted indices by AUC performance: " , test_sorted_indices))

# Use the sorted indices to get the sorted trainAUCs
sorted_testAUCs <- testAUCs[test_sorted_indices[1]] #<-- get max value:

# Print the sorted AUC values
print(paste0("TEST best AUC: ", sorted_testAUCs))

testSetScores <- testPhenoOrdered[,c("IID", "PHENOTYPE")]
testSetScores <- as.data.frame(cbind(testSetScores, testPredGrid))

write.table(testSetScores, file = file.path(args$write_path, "Test_ALL_Preds.tsv"), sep = "\t", row.names = FALSE, quote = FALSE)

